<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.8.0/p5.js"></script>
    <title>say hi to my bars</title>
    <style>
        h1 {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            animation: blink 3s infinite; /* 깜빡임 효과 유지 */
        }
        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }  /* 보임 */
            25%, 75% { opacity: 0; }       /* 안 보임 */
        }
        body, html {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background: #fff; /* Set a background color that matches your design */
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
        #main-content {
            position: relative;
            z-index: 10; /* Ensure it's above the p5.js canvas */
        }
        /* Tailwind CSS doesn't come with grid-gap utilities by default, you might need to add custom CSS if needed */
        
        
    </style>
</head>
<body class="overflow-hidden">
    <h1>THESE ARE MY BABIES</h1>

  

    </class=>

    <!-- Image grid -->
    <div class="absolute bottom-0 w-full grid grid-cols-3 gap-40 p-3">
        <!-- Add your image tags here -->

       
        <!-- Add more images as needed -->
    </div>
    <script src="cargo3-2025/active2.js"></script>

    <script>
        let blocks = [];
let lastScrollY = 0;
let blockWidth = 120; // Width of the blocks
let blockHeight = 30; // Height of the blocks

let draggingBlock = null;
let offsetX = 0;
let offsetY = 0;

function setup() {
    createCanvas(windowWidth, windowHeight);
    // Define specific positions and orientations for each block
    const blockData = [
        { x: width * 0.4, y: height * 0.3, orientation: 'vertical'},
        { x: width * 0.37, y: height * 0.35, orientation: 'vertical' },
        { x: width * 0.34, y: height * 0.4, orientation: 'vertical' },
        { x: width * 0.45, y: height * 0.35, orientation: 'horizontal' },
        { x: width * 0.48, y: height * 0.3, orientation: 'horizontal' },
        { x: width * 0.48, y: height * 0.45, orientation: 'horizontal' },
        { x: width * 0.51, y: height * 0.35, orientation: 'horizontal' },
        { x: width * 0.54, y: height * 0.3, orientation: 'horizontal' },
    ];
    for (let i = 0; i < blockData.length; i++) {
        blocks.push({
            x: blockData[i].x,
            y: blockData[i].y,
            dx: 0,
            dy: 0,
            initialX: blockData[i].x,
            initialY: blockData[i].y,
            scrollFactor: random(0.5, 1),
            orientation: blockData[i].orientation
        });
    }
}
function draw() {
    clear();
    let currentScrollY = window.scrollY;
    let scrollDelta = currentScrollY - lastScrollY;
    blocks.forEach(block => {
        // Magnetic attraction
        let attractionX = (block.initialX - block.x) * 0.001; // Horizontal attraction
        let attractionY = (block.initialY - block.y) * 0.001; // Vertical attraction
        block.dx += attractionX;
        block.dy += attractionY;
        // Interaction with mouse position
        let distToMouse = dist(mouseX, mouseY, block.x, block.y);
        if (distToMouse < 600) {
            let angle = atan2(mouseY - block.y, mouseX - block.x);
            let forceMagnitude = map(distToMouse, 0, 600, 0.2, 0); // Reduced force magnitude for smoother effect
            let forceX = cos(angle) * forceMagnitude;
            let forceY = sin(angle) * forceMagnitude;
            block.dx += forceX;
            block.dy += forceY;
        }
        // Apply position changes with damping
        block.x += block.dx;
        block.y += block.dy;
        block.dx *= 0.9;
        block.dy *= 0.9;
        // Draw block with original resizing
        fill(0, 10, 10); // Constant color
        let drawWidth = block.orientation === 'horizontal' ? blockHeight : blockWidth;
        let drawHeight = block.orientation === 'horizontal' ? blockWidth : blockHeight;
        rect(block.x, block.y, drawWidth, drawHeight);
    });
    lastScrollY = currentScrollY;
}
function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}
function mouseWheel(event) {
    let verticalScrollChange = event.deltaY * 0.01;
    let horizontalScrollChange;
    blocks.forEach(block => {
        horizontalScrollChange = random(-4, 4);
        block.dx += horizontalScrollChange * 0.1 * block.scrollFactor;
        block.dy += verticalScrollChange * block.scrollFactor;
    });
}
function mouseClicked() {
    blocks.forEach(block => {
        block.dx += random(-20, 20);
        block.dy += random(-20, 20);
        
    });
    setTimeout(() => {
        blocks.forEach(block => {
            block.dx = 0;
            block.dy = 0;
        });
    }, 3000); // Change the duration to the desired time in milliseconds
}

function mousePressed() {
    for (let block of blocks) {
        let drawWidth = block.orientation === 'horizontal' ? blockHeight : blockWidth;
        let drawHeight = block.orientation === 'horizontal' ? blockWidth : blockHeight;
        if (
            mouseX > block.x && mouseX < block.x + drawWidth &&
            mouseY > block.y && mouseY < block.y + drawHeight
        ) {
            draggingBlock = block;
            offsetX = mouseX - block.x;
            offsetY = mouseY - block.y;
            break;
        }
    }
}

function mouseDragged() {
    if (draggingBlock) {
        draggingBlock.x = mouseX - offsetX;
        draggingBlock.y = mouseY - offsetY;
        draggingBlock.dx = 0;
        draggingBlock.dy = 0;
    }
}

function mouseReleased() {
    draggingBlock = null;
}

blocks.forEach(block => {
    if (block !== draggingBlock) {
        // 기존의 힘 계산 그대로 사용
    }
    // 블록 그리기는 그대로
});



    </script>
</body>
</html>
